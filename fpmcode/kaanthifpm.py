# -*- coding: utf-8 -*-
"""Copy of FPM w demosaicing / SSR

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ks_1xvzfY-c8aTztOf7ShZddoROS8T21
"""

# imports
import matplotlib.pyplot as plt
from matplotlib import colors
import numpy as np
from numpy.fft import fft, ifft, fft2, ifft2, fftshift, ifftshift
import os
import scipy.io as sio

import matplotlib as mpl
mpl.rcParams['figure.dpi'] = 100

# # create dataset
# from scipy.io import savemat

# NAshift_x = [0.00946659534264582,0.00944227240025124,0.0796086793974973,0.0798124775384481,0.0796250151712776,0.00944422200294259,-0.0608753240631139,-0.0610190204346216,-0.0608628022542984,-0.0604133716953491,0.00937230033272502,0.0790223420184577,0.147542567203096,0.148620002330936,0.148994485026304,0.148650021260099,0.147601330713472,0.0790543089103629,0.00937611492782555,-0.0604378737875679,-0.129382638091795,-0.130306622086625,-0.130610145351225,-0.130280171507172,-0.129330865489912,-0.127801943612947,-0.0596899611763397,0.00925968387314670,0.0780784927884627,0.145807033642697,0.211559986441118,0.214017379463403,0.215541899669074,0.216071585249947,0.215584363444683,0.214100547924802,0.211680538712400,0.145892139425992,0.0781247645373782,0.00926520427197373,-0.0597254244861813,-0.127876911404480,-0.194276620490598,-0.196514176257007,-0.197886400152351,-0.198337026552701,-0.197847126938496,-0.196437268845415,-0.194165171743160,-0.191119367754963,-0.125754219177150,-0.0587215969972973,0.00910895636467990,0.0768149131916996,0.143482109050706,0.208264813903688,0.270435612735578,0.274579812121335,0.277666403703266,0.279579546770101,0.280243946994172,0.279632816242297,0.277770807118284,0.274731310396262,0.270628679346941,0.208418219959045,0.143590287745033,0.0768736873242968,0.00911596634852447,-0.0587666368971736,-0.125849489114490,-0.191261141804185,-0.254236893836665,-0.258127211297253,-0.261010468424377,-0.262777213520797,-0.263357152499581,-0.262726664649925,-0.260911416629909,-0.257983524141562,-0.254053858516429,-0.249261042975617,-0.187410176116581,-0.123263282013841,-0.0575444251194328,0.00892576088726852,0.0752786653306695,0.140653244710982,0.204250454808602,0.265378791914623,0.323485376101353,0.329418811469476,0.334272119778291,0.337881345442940,0.340116047920784,0.340891691268842,0.340178244672909,0.338003344053621,0.334449380558016,0.329645100486751,0.323753332601231,0.265606933159348,0.204431413679650,0.140780682599425,0.0753478435298565,0.00893400895176747,-0.0575974302673736,-0.123375481584899,-0.187577346597272,-0.249477221335209,-0.308481752371425,-0.314157134526011,-0.318787444609280,-0.322214166528023,-0.324311815745638,-0.325000023617159,-0.324251821657598,-0.322096515150017,-0.318616562747410,-0.313939094936589,-0.308223715661202,-0.301648739228690,-0.243759141638005,-0.183159675558594,-0.120412512512464,-0.0561982407894797,0.00871630701692532,0.0735215823064291,0.137414768290844,0.199648282261524,0.259570699307019,0.316655271057350,0.370513944685286,0.378170319432511,0.384804982092737,0.390220252907880,0.394240538808926,0.396726802227396,0.397589229379015,0.396795968038640,0.394376329268401,0.390417839155634,0.385057706388176,0.378470277657527,0.370852600139390,0.316956998489772,0.259826990600804,0.199851169793015,0.137557434805605,0.0735989524806431,0.00872552828318718,-0.0562575131827754,-0.120538080336203,-0.183347019189864,-0.244001855844074,-0.301939104227797,-0.356732257282156,-0.364148946826077,-0.370566977593632,-0.375792343474670,-0.379653101726653,-0.382013760187440,-0.382787811328199,-0.381946272303165,-0.379520638364635,-0.375599675597358,-0.370320675814788,-0.363856800091150,-0.356402662270177,-0.348160264846537,-0.294397938994294,-0.237705944011760,-0.178492253777858,-0.117286544972657,-0.0547233459346040,0.00848687949978865,0.0715961808521199,0.133862510104416,0.194592322893583,0.253176847686621,0.309117917341547,0.362041456707279,0.411698991842747,0.420897553538207,0.429185411345255,0.436348069780772,0.442180898606690,0.446503311031831,0.449173038229227,0.450098498531999,0.449247270771582,0.446649188462052,0.442393490768714,0.436620550057851,0.429509627828322,0.421264638315878,0.412099930241090,0.362410204146139,0.309445518044299,0.253454411912613,0.194811586338828,0.134016443777103,0.0716795751479876,0.00849681468490139,-0.0547872223356298,-0.117421984031197,-0.178694620589969,-0.237968643332669,-0.294712977514561,-0.348518862411085,-0.399104392241122,-0.408095444584784,-0.416190758192934,-0.423177678142221,-0.428853472970390,-0.433039606835646,-0.435596084764788,-0.436433824723216,-0.435523031805877,-0.432896084897958,-0.428644401683507,-0.422909861590869,-0.415872308499360,-0.407735169071104,-0.398711223442509]
# NAshift_y = [-0.00147915552228841,-0.0718900285019128,-0.0716665303276093,-0.00147453351179531,0.0687390960665716,0.0689535526919387,0.0688295569037407,-0.00147648311654386,-0.0717608051216540,-0.140999972214618,-0.141250151321324,-0.140817441856875,-0.139720335418141,-0.0710998940105156,-0.00146281625784483,0.0681953864045793,0.136877706721972,0.137953353976935,0.138377605255834,0.138132316025700,0.137228012430967,0.0683724007273634,-0.00146663086858256,-0.0712843731398980,-0.140077631977130,-0.206914947499116,-0.208245223109711,-0.208605946346742,-0.207982011357914,-0.206399460333200,-0.203922534639367,-0.138004399909244,-0.0702142082305966,-0.00144450433800254,0.0673455468643292,0.135195374555652,0.201208437186212,0.203655217834926,0.205218561868424,0.205834935814870,0.205478583142075,0.204164444096169,0.201946453839755,0.135702664582633,0.0676017610516472,-0.00145002478537798,-0.0704812309178743,-0.138521827891124,-0.204669654648845,-0.268146341440069,-0.270995464151657,-0.272682118920578,-0.273139302355671,-0.272348474551021,-0.270341603182828,-0.267197655372971,-0.263034269482495,-0.200646692786784,-0.135737216333010,-0.0690447093018680,-0.00142032962446366,0.0662234000868692,0.132972663378132,0.197972617701692,0.260478856964504,0.264607792326756,0.267725911370380,0.269716380282929,0.270500762813460,0.270047304175529,0.268374420947498,0.265548667572074,0.261677607028376,0.198911587735960,0.133617400814410,0.0665488213193189,-0.00142733971102453,-0.0693838649252857,-0.136394862556333,-0.201597294682951,-0.264243050516448,-0.323734779899353,-0.328335254714414,-0.331688455888613,-0.333671589561867,-0.334208887767609,-0.333279411843542,-0.330919272633120,-0.327217818691791,-0.322308558554620,-0.316356552423821,-0.257996256960772,-0.196689019057791,-0.133001449697618,-0.0676345632134527,-0.00139118817391013,0.0648703783341528,0.130290670947433,0.194063527191785,0.255482902321296,0.313976111679016,0.319893348359075,0.324774349920144,0.328454752155389,0.330801583787445,0.331725843748865,0.331191558994533,0.329219588467665,0.325885407420756,0.321311320738193,0.315654623306547,0.256899026863241,0.195170893043495,0.131050073993039,0.0652533755943231,-0.00139943641266294,-0.0680337338168294,-0.133776091197905,-0.197810173223750,-0.259424344089540,-0.318044983356662,-0.373252824200223,-0.379642612691039,-0.384798441074514,-0.388550379799814,-0.390766914068511,-0.391367137507114,-0.390328722993991,-0.387690184369295,-0.383546991751962,-0.378042287370756,-0.371353903618121,-0.363679846960063,-0.309544454733604,-0.252242987578489,-0.192177779503136,-0.129887346812902,-0.0660307930672848,-0.00135805537298765,0.0633316133312202,0.127237922652425,0.189607968090738,0.249778148256397,0.307204479504650,0.361478795130277,0.369120730971060,0.375781848274938,0.381264629865245,0.385391635000708,0.388020006443968,0.389054450013133,0.388456519755240,0.386248503649798,0.382511161263446,0.377375751623250,0.371011840668228,0.363612987273895,0.309093826147346,0.251368494672392,0.190849209376018,0.128087924631119,0.0637599275023847,-0.00136727689460001,-0.0664772054664555,-0.130754447754539,-0.193434564715356,-0.253846910847194,-0.311445163345978,-0.365823098920648,-0.416716046312617,-0.424783059239398,-0.431702852595265,-0.437273991376568,-0.441321156358935,-0.443709311735483,-0.444355651082682,-0.443237357441911,-0.440393798861904,-0.435922755673847,-0.429971369596796,-0.422723396646488,-0.414384799845680,-0.405169670511125,-0.355224319627883,-0.302059257837906,-0.245936555590113,-0.187242725794364,-0.126485826081266,-0.0642806505288797,-0.00132191047254018,0.0616524529226767,0.123903590220557,0.184734185817875,0.243525479006475,0.299764555759928,0.353059673111961,0.403143628024605,0.412331073155960,0.420645684541927,0.427873647828886,0.433809196757910,0.438268698678424,0.441105077833769,0.442220582464183,0.441575852700721,0.439193700990513,0.435156912030869,0.429600467664021,0.422699580996380,0.414655511064494,0.405681211000241,0.355382455904022,0.301815081261812,0.245247231215419,0.186075245998360,0.124820549160028,0.0621140730092385,-0.00133184599455012,-0.0647617891161155,-0.127421280052359,-0.188600682758154,-0.247673172562372,-0.304122345115773,-0.357557251687777,-0.407715022362838]
# NA = 0.1200
# spsize = 1.047619047619048e-06
# wlength = 6.300000000000000e-07

# numImages = 225

# images = []
# for i in range(numImages):
#     im = np.load('C:/Users/HMCBiophotonicsLab/Documents/RPi_Data_Share/2021Jun7/im_' + str(i) + '.npy',allow_pickle=True)
#     images.append(im)
# mdic = {"imseqlow": float(images), "NA": NA, "NAshift_x": NAshift_x, "NAshift_y": NAshift_y, "spsize": spsize, "wlength": wlength}
# savemat("test_dataset.mat", mdic)

# Mount Google Drive
# When you run this, it will give you a URL. Go to that URL, copy the code, and enter it into the box
#%%
def colorbar(mappable):
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    import matplotlib.pyplot as plt
    last_axes = plt.gca()
    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    cbar = fig.colorbar(mappable, cax=cax)
    plt.sca(last_axes)
    return cbar
#%%
# Load .mat file
data_mat = '/home/kevin/Harvey Mudd/biophotonics/github/BiophotonicsLab/fpmcode/k_dataset.mat'
#data_mat = 'gdrive/Shared drives/HMC Biophotonics Lab/Tutorials/FPM Algorithm/FPM Data/input_data_USAF.mat'
data_mat_norm = os.path.relpath(data_mat)
data = sio.loadmat(data_mat_norm)
#%%
#define LED specifications
arraysize = 15
LEDgap = 4 # 4mm between adj LED's
#LEDheight = 56 # for caltech datasets
LEDheight = 95 # dist between LED and sample
# 1-D x and y position vectors
xloc = np.arange(-arraysize*LEDgap//2,arraysize*LEDgap//2,LEDgap)+(LEDgap+1)//2
yloc = np.arange(-arraysize*LEDgap//2,arraysize*LEDgap//2,LEDgap)+(LEDgap+1)//2
print(xloc)
print(yloc)

# 2x2 coordinate matrices for x and y
# ex. X[0] represents all the x values at y=0
# ex. Y[0] represents all the y values at x=0
# more information here: https://www.geeksforgeeks.org/numpy-meshgrid-function/

X,Y = np.meshgrid(xloc,yloc)
X = X.flatten()
Y = Y.flatten()

kx_relative = -np.sin(np.arctan2(X,LEDheight))
ky_relative = -np.sin(np.arctan2(Y,LEDheight))
#%%
i = 112
print(f"kx_r = {kx_relative[i]} ky_r = {ky_relative[i]}")
#%%
# Save dictionary elements to variables for easier manipulation
#print(data)
imseqlow = data['imseqlow'] #sequence of low resolution images (225 images, each 128x128 in size)
bg = data['background']
for i in range(arraysize**2): 
  imseqlow[:, :, i] = imseqlow[:, :, i] -bg
  

#normalize darkfield images
imseqlow[:, :, 47:225] = imseqlow[:, :, 47:225]/6.316
#%%
def cropped(seq, width, height):
    yMid = seq.shape[0]//2
    xMid = seq.shape[1]//2
    cropped_seq = seq[yMid-height//2:yMid+height//2,xMid-width//2:xMid+width//2,:]
    return cropped_seq
    
imseqlow_crop = cropped(imseqlow, 256,256)
fig,ax=plt.subplots(1,1)
ax.imshow(imseqlow_crop[:,:,0]) 
   


#imseqlow = imseqlow - bg
#print(bg.shape)
#NAshift_x = data['NAshift_x'][0] #x component of NA shift of the illumination (+ means to the right in k space)
#NAshift_y = data['NAshift_y'][0] #y component of NA shift of the illumination (+ means to down in k space)
#%%
# Resolution line plots

fig, ax = plt.subplots(1)

img = ax.imshow(imseqlow[:,:,0])
colorbar(img)

#ax[0,1].plot(imseqlow[:,0,0])

#ax[0,1].set_ylim(bottom = 0)
#%%
scaling_factor = 4              
[m,n] = (1024,1024)          #image size of the high resolution object
#[m, n] = (512, 512)
m1 = m//(scaling_factor)  #image size of low res reconstruction (low res)
n1 = n//(scaling_factor)
print(m1, n1)
#imSeqLowRes = np.zeros([m1,n1, arraysize**2]) #image sequence of low-resolution images. 225 (128 x 128) images for 225 LEDs!
#img_frames = np.zeros([m,n, arraysize**2])

# function to initialize paramters for dataset and create CTF mask
def initialize_params(data):
  k0 = 2*np.pi/data['wlength'][0][0]
  spsize = data['spsize'][0]           #sensor pixel size
  psize = spsize/scaling_factor #hi-res pixel size (smaller than the sensor pixel size)
  NA = data['NA'][0][0]

  kx = k0 * kx_relative
  ky = k0 * ky_relative

  dkx = 2*np.pi/(psize * n)      #size of pixel in the spatial frequency domain
  dky = 2*np.pi/(psize * m)
  cutoffFrequency = NA*k0
  kmax= np.pi/spsize

  kx_lowres = np.linspace(-kmax, kmax, n1,endpoint=False)
  ky_lowres = np.linspace(-kmax, kmax, m1,endpoint=False)
  kxm, kym = np.meshgrid(kx_lowres, ky_lowres)
  CTF = ((kxm**2 + kym **2) < cutoffFrequency ** 2)
  return (k0, kx, ky, dkx, dky, CTF)
#%%
try:
    import colour
except ImportError as e:
    !pip install colour_demosaicing 

import colour
import colour_demosaicing
from colour_demosaicing import (demosaicing_CFA_Bayer_bilinear)
from colour_demosaicing import (masks_CFA_Bayer)

m1,n1 = 800,800
imseqlowDM = np.empty((m1, n1,  arraysize**2))
imseqlowSSR = np.empty((m1, n1,  arraysize**2))
imseqlowNA = np.empty((m1, n1,  arraysize**2))
ssr_mask = masks_CFA_Bayer((m1, n1), pattern='BGGR')[0]

for i in range(arraysize**2):
  bayer_data = imseqlow[:,:,i]
  
  # bayer_data = np.load('/content/gdrive/Shareddrives/HMC Biophotonics Lab/Data/UC2_FPM/20210317/im_center_bayer_test.npy')
  np.shape(bayer_data)
  img_ssr = bayer_data * ssr_mask
  img_demosaic = demosaicing_CFA_Bayer_bilinear(bayer_data, pattern = 'GBRG')[:, :, 0]
  img_demosaic2 = demosaicing_CFA_Bayer_bilinear(bayer_data, pattern = 'BGGR')[:, :, 0]
  ##img_demosaic = demosaicing_CFA_Bayer_bilinear(bayer_data, pattern = 'RGGB')[:, :, 0] #i think its supposed to be RGGB not BGGR? 
  imseqlowDM[:, :, i] = img_demosaic
  imseqlowNA[:, :, i] = img_demosaic2
  imseqlowSSR[:, :, i] = img_ssr
#%%
print(imseqlowDM.shape)
print(imseqlowSSR.shape)
print(img_demosaic.shape)
print(bayer_data.shape)
print(imseqlow.shape)
#print(im_dir[:,:,i].shape)
#print(bayer_mask)

fig, ax = plt.subplots(2, 2)
#fig.set_size_inches(6,4)
i = 1
ax[0, 0].imshow(imseqlowNA[:, :, i])
ax[0,0].set_title('Demosaic: GBRG')
ax[0,1].imshow(imseqlowSSR[:, :, i])
ax[0,1].set_title('SSR')
ax[1,0].imshow(imseqlowDM[:,:, i])
ax[1,0].set_title('Demosaic: BGGR')
ax[1,1].imshow(imseqlow[:,:,i])
ax[1,1].set_title('OG')

# for item in ([ax[0,0].title, ax[0,0].xaxis.label, ax[0,0].yaxis.label] +
#              ax[0,0].get_xticklabels() + ax[0,0].get_yticklabels()):
#     item.set_fontsize(20)


plt.tight_layout()  

fig,ax = plt.subplots()
ax.imshow(imseqlowDM[:,:, i])
ax.set_title('Demosaiced Low Res Image')


fig,ax = plt.subplots()
ax.imshow(imseqlowSSR[:,:, i])
ax.set_title('SSR Low Res Image')
#%%
#calculate new NAshift values
import math
NAshift_x_new = []
NAshift_y_new = []
LED_y = [7,8,8,7,6,6,6,7,8,9,9,9,9,8,7,6,5,5,5,5,5,6,7,8,9,10,10,10,10,10,10,9,8,7,6,5,4,4,4,4,4,4,4,5,6,7,8,9,10,11,11,11,11,11,11,11,11,10,9,8,7,6,5,4,3,3,3,3,3,3,3,3,3,4,5,6,7,8,9,10,11,12,12,12,12,12,12,12,12,12,12,11,10,9,8,7,6,5,4,3,2,2,2,2,2,2,2,2,2,2,2,3,4,5,6,7,8,9,10,11,12,13,13,13,13,13,13,13,13,13,13,13,13,12,11,10,9,8,7,6,5,4,3,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]
LED_x = [7,7,6,6,6,7,8,8,8,8,7,6,5,5,5,5,5,6,7,8,9,9,9,9,9,9,8,7,6,5,4,4,4,4,4,4,4,5,6,7,8,9,10,10,10,10,10,10,10,10,9,8,7,6,5,4,3,3,3,3,3,3,3,3,3,4,5,6,7,8,9,10,11,11,11,11,11,11,11,11,11,11,10,9,8,7,6,5,4,3,2,2,2,2,2,2,2,2,2,2,2,3,4,5,6,7,8,9,10,11,12,12,12,12,12,12,12,12,12,12,12,12,11,10,9,8,7,6,5,4,3,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,11,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,12,11,10,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14]
for i in range(len(LED_x)):
    x_loc = LED_x[i] - (arraysize//2)
    y_loc = LED_y[i] - (arraysize//2)
    dist = np.sqrt((x_loc*LEDgap)**2 + (y_loc*LEDgap)**2)

    phi = math.atan2((y_loc*LEDgap), (x_loc*LEDgap))
    theta = math.atan2(dist, LEDheight)

    kx_rel = (np.sin(theta)*np.cos(phi))
    ky_rel = (np.sin(theta)*np.sin(phi))
    
    NAshift_x_new.append(kx_rel); NAshift_y_new.append(ky_rel)
#%%
fig, ax = plt.subplots()
ax.plot(NAshift_x_new,NAshift_y_new,'o')
ax.axis('equal')
ax.set_xlabel('kx relative')
ax.set_ylabel('ky relative')
ax.set_title('ky vs. kx relative')
#%%
# function to reconstruct the high res image and phase
import cv2

def phaseRetrieval(iterations, scaling_factor, k0, kx, ky, dkx, dky, CTF, seq, NAshift_x = NAshift_x_new, NAshift_y = NAshift_y_new):
    #objectRecover = np.ones([m,n])
    objectRecover = cv2.resize(seq[:, :, 0], dsize=(m, n), interpolation=cv2.INTER_CUBIC)
    
    objectRecoverFT = fftshift(fft2(objectRecover))
    for i in range(iterations):
        print("iteration: ", i)
        for j in range(arraysize**2):
            limg = j
            
            kxc = np.round(n/2 + k0 * NAshift_x[limg]/dkx)
            kyc = np.round(m/2 + k0 * NAshift_y[limg]/dky)
            kyl = np.round(kyc - (m1)/2); kyh = np.round(kyc + (m1)/2)
            kxl = np.round(kxc - (n1)/2); kxh=np.round(kxc + (n1)/2)
            kxl = int(kxl)
            kyl = int(kyl)
            kxh = int(kxh)
            kyh = int(kyh)

            lowResFT = (scaling_factor)**2 * objectRecoverFT[kyl:kyh, kxl:kxh] * CTF
            im_lowRes = ifft2(ifftshift(lowResFT));
            im_lowRes = (1/scaling_factor)**2 * seq[:,:,limg] * np.exp(1j * np.angle(im_lowRes))
            lowResFT = fftshift(fft2(im_lowRes)) * CTF
            objectRecoverFT[kyl:kyh,kxl:kxh] = (1-CTF) * objectRecoverFT[kyl:kyh,kxl:kxh] + lowResFT
    objectRecover = ifft2(ifftshift(objectRecoverFT))
    return (objectRecover,objectRecoverFT)
#%%
#print(imseqlow[:, :, 0])
#objectRecover = cv2.resize(imseqlow[:, :, 0], dsize=(m, n), interpolation=cv2.INTER_NEAREST)
#print(objectRecover)
#%%
print(imseqlowDM.shape)
k0, kx, ky, dkx, dky, CTF = initialize_params(data)

HighResDM, HighResFTDM = phaseRetrieval(5, scaling_factor, k0, kx, ky, dkx, dky, CTF, imseqlowDM)

HighResSSR, HighResFTSSR = phaseRetrieval(5, scaling_factor, k0, kx, ky, dkx, dky, CTF, imseqlowSSR)
#HighResSSR = HighResSSR * 4
HighRes, HighResFT = phaseRetrieval(5, scaling_factor, k0, kx, ky, dkx, dky, CTF, imseqlowNA)
#%%
#helper function to plot things
def plot3(image, title): 
  norm_img = np.abs(image) / np.abs(image).max()
  plt.rcParams["figure.figsize"] = (40,10)
  fig, ax = plt.subplots(1, 3)
  norm1 = colors.Normalize(vmin = norm_img.min(), vmax = norm_img.max())
  #print(norm_img[0:100])
  # for i in range(0, len(norm_img)): 
  #   for j in range(0, len(norm_img[0])):
  #     if norm_img[i] = 

  
  h0 = ax[0].imshow(np.abs(image), cmap = 'viridis', vmin = 0, vmax = 5 * np.mean(np.abs(image)))
  #h0 = ax[0].imshow(norm_img, cmap = 'viridis', vmin = 0, vmax = 2 * np.mean(norm_img))

  #h0 = ax[0].imshow(norm_img, cmap = 'viridis', norm = norm1)
  colorbar(h0)
 

  ax[0].set_title("High Res Intensity " + title)
  ax[0].set_xlabel("x")
  ax[0].set_ylabel("y")
  import matplotlib.patches as mpatches
  rect=mpatches.Rectangle((1600,1300),1,200, fill = False, color = "red", linewidth = 2)
  ax[0].add_patch(rect)


  phaseimg = np.angle(image) + np.abs(np.angle(image).min())
  norm_angle = phaseimg / phaseimg.max()
  #h1 = ax[1].imshow(np.angle(image),  cmap = 'viridis', vmin = -0.5, vmax = 0.5)
  norm2 = colors.Normalize(vmin = norm_angle.min(), vmax = norm_angle.max())
  h1 = ax[1].imshow(norm_angle, cmap = 'viridis', norm = norm2)
  ax[1].set_title("High Res Phase " + title)
  ax[1].set_xlabel("x")
  ax[1].set_ylabel("y")
  colorbar(h1)

  ax[2].plot(norm_img[1300:1500, 1600])
  norm_img[1300:1500, 1595:1605] = 30000
  ax[2].set_title("line profile")
  #ax[2].set_ylim(bottom = 0, top = 1)
  ax[2].set_xlabel("distance (pixels)")
  ax[2].set_ylabel("intensity")
  
  for i in range(3): 
    for item in ([ax[i].title, ax[i].xaxis.label, ax[i].yaxis.label] +
              ax[i].get_xticklabels() + ax[i].get_yticklabels()):
      item.set_fontsize(20)
#%%
print(np.angle(HighRes) + np.abs(np.angle(HighRes).min()))
#%%
plot3(HighRes, "Original")
plot3(HighResDM, "Demosaiced")
plot3(HighResSSR, "SSR")
#%%
#helper function to plot things
def plot4(image, title): 
  norm_img = np.abs(image) / np.abs(image).max()
  plt.rcParams["figure.figsize"] = (40,10)
  fig, ax = plt.subplots()
  norm1 = colors.Normalize(vmin = norm_img.min(), vmax = norm_img.max())
  #print(norm_img[0:100])
  # for i in range(0, len(norm_img)): 
  #   for j in range(0, len(norm_img[0])):
  #     if norm_img[i] = 

  
  h0 = ax.imshow(np.abs(image), cmap = 'viridis', vmin = 0, vmax = 5 * np.mean(np.abs(image)))
  #h0 = ax[0].imshow(norm_img, cmap = 'viridis', vmin = 0, vmax = 2 * np.mean(norm_img))

  #h0 = ax[0].imshow(norm_img, cmap = 'viridis', norm = norm1)
  colorbar(h0)
 

  ax.set_title("High Res Intensity " + title)
  ax.set_xlabel("x")
  ax.set_ylabel("y")

plot4(HighResSSR, "SSR")

#aaaaaaAAAAAAAAAAAAAAAAAA
#%%
# RMS plot calculations
def RMS(image): 
  norm_img = np.abs(image) / np.abs(image).max()
  norm_img_sq = norm_img ** 2
  mean = np.mean(norm_img_sq)
  rms = np.sqrt(mean)
  return rms
#%%id
#calculate RMS error
def rms_error(image, truth): 
  rmsimg = RMS(image)
  rmstruth = RMS(truth)
  return (np.abs(rmstruth - rmsimg) / rmstruth) * 100

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

fig, ax = plt.subplots()


def f(x, y):
    return np.sin(x) + np.cos(y)

x = np.linspace(0, 2 * np.pi, 120)
y = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)

# ims is a list of lists, each row is a list of artists to draw in the
# current frame; here we are just animating one artist, the image, in
# each frame
ims = []
for i in range(60):
    x += np.pi / 15.
    y += np.pi / 20.
    im = ax.imshow(f(x, y), animated=True)
    if i == 0:
        ax.imshow(f(x, y))  # show an initial one first
    ims.append([im])

ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,
                                repeat_delay=1000)

# To save the animation, use e.g.
#
# ani.save("movie.mp4")
#
# or
#
# writer = animation.FFMpegWriter(
#     fps=15, metadata=dict(artist='Me'), bitrate=1800)
# ani.save("movie.mp4", writer=writer)

plt.show()7

print(RMS(HighRes))
print(RMS(HighResDM))
print(RMS(HighResSSR))
print(rms_error(HighResDM, HighRes))
print(rms_error(HighResSSR, HighRes))