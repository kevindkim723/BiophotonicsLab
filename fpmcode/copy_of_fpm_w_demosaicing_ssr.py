# -*- coding: utf-8 -*-
"""Copy of FPM w demosaicing / SSR

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ks_1xvzfY-c8aTztOf7ShZddoROS8T21
"""

# imports
import matplotlib.pyplot as plt
from matplotlib import colors
import numpy as np
from numpy.fft import fft, ifft, fft2, ifft2, fftshift, ifftshift
import os
import scipy.io as sio
import numpy.matlib 
import sys
import matplotlib as mpl
mpl.rcParams['figure.dpi'] = 100
numpy.set_printoptions(threshold=sys.maxsize)
# # create dataset
# from scipy.io import savemat

# NAshift_x = [0.00946659534264582,0.00944227240025124,0.0796086793974973,0.0798124775384481,0.0796250151712776,0.00944422200294259,-0.0608753240631139,-0.0610190204346216,-0.0608628022542984,-0.0604133716953491,0.00937230033272502,0.0790223420184577,0.147542567203096,0.148620002330936,0.148994485026304,0.148650021260099,0.147601330713472,0.0790543089103629,0.00937611492782555,-0.0604378737875679,-0.129382638091795,-0.130306622086625,-0.130610145351225,-0.130280171507172,-0.129330865489912,-0.127801943612947,-0.0596899611763397,0.00925968387314670,0.0780784927884627,0.145807033642697,0.211559986441118,0.214017379463403,0.215541899669074,0.216071585249947,0.215584363444683,0.214100547924802,0.211680538712400,0.145892139425992,0.0781247645373782,0.00926520427197373,-0.0597254244861813,-0.127876911404480,-0.194276620490598,-0.196514176257007,-0.197886400152351,-0.198337026552701,-0.197847126938496,-0.196437268845415,-0.194165171743160,-0.191119367754963,-0.125754219177150,-0.0587215969972973,0.00910895636467990,0.0768149131916996,0.143482109050706,0.208264813903688,0.270435612735578,0.274579812121335,0.277666403703266,0.279579546770101,0.280243946994172,0.279632816242297,0.277770807118284,0.274731310396262,0.270628679346941,0.208418219959045,0.143590287745033,0.0768736873242968,0.00911596634852447,-0.0587666368971736,-0.125849489114490,-0.191261141804185,-0.254236893836665,-0.258127211297253,-0.261010468424377,-0.262777213520797,-0.263357152499581,-0.262726664649925,-0.260911416629909,-0.257983524141562,-0.254053858516429,-0.249261042975617,-0.187410176116581,-0.123263282013841,-0.0575444251194328,0.00892576088726852,0.0752786653306695,0.140653244710982,0.204250454808602,0.265378791914623,0.323485376101353,0.329418811469476,0.334272119778291,0.337881345442940,0.340116047920784,0.340891691268842,0.340178244672909,0.338003344053621,0.334449380558016,0.329645100486751,0.323753332601231,0.265606933159348,0.204431413679650,0.140780682599425,0.0753478435298565,0.00893400895176747,-0.0575974302673736,-0.123375481584899,-0.187577346597272,-0.249477221335209,-0.308481752371425,-0.314157134526011,-0.318787444609280,-0.322214166528023,-0.324311815745638,-0.325000023617159,-0.324251821657598,-0.322096515150017,-0.318616562747410,-0.313939094936589,-0.308223715661202,-0.301648739228690,-0.243759141638005,-0.183159675558594,-0.120412512512464,-0.0561982407894797,0.00871630701692532,0.0735215823064291,0.137414768290844,0.199648282261524,0.259570699307019,0.316655271057350,0.370513944685286,0.378170319432511,0.384804982092737,0.390220252907880,0.394240538808926,0.396726802227396,0.397589229379015,0.396795968038640,0.394376329268401,0.390417839155634,0.385057706388176,0.378470277657527,0.370852600139390,0.316956998489772,0.259826990600804,0.199851169793015,0.137557434805605,0.0735989524806431,0.00872552828318718,-0.0562575131827754,-0.120538080336203,-0.183347019189864,-0.244001855844074,-0.301939104227797,-0.356732257282156,-0.364148946826077,-0.370566977593632,-0.375792343474670,-0.379653101726653,-0.382013760187440,-0.382787811328199,-0.381946272303165,-0.379520638364635,-0.375599675597358,-0.370320675814788,-0.363856800091150,-0.356402662270177,-0.348160264846537,-0.294397938994294,-0.237705944011760,-0.178492253777858,-0.117286544972657,-0.0547233459346040,0.00848687949978865,0.0715961808521199,0.133862510104416,0.194592322893583,0.253176847686621,0.309117917341547,0.362041456707279,0.411698991842747,0.420897553538207,0.429185411345255,0.436348069780772,0.442180898606690,0.446503311031831,0.449173038229227,0.450098498531999,0.449247270771582,0.446649188462052,0.442393490768714,0.436620550057851,0.429509627828322,0.421264638315878,0.412099930241090,0.362410204146139,0.309445518044299,0.253454411912613,0.194811586338828,0.134016443777103,0.0716795751479876,0.00849681468490139,-0.0547872223356298,-0.117421984031197,-0.178694620589969,-0.237968643332669,-0.294712977514561,-0.348518862411085,-0.399104392241122,-0.408095444584784,-0.416190758192934,-0.423177678142221,-0.428853472970390,-0.433039606835646,-0.435596084764788,-0.436433824723216,-0.435523031805877,-0.432896084897958,-0.428644401683507,-0.422909861590869,-0.415872308499360,-0.407735169071104,-0.398711223442509]
# NAshift_y = [-0.00147915552228841,-0.0718900285019128,-0.0716665303276093,-0.00147453351179531,0.0687390960665716,0.0689535526919387,0.0688295569037407,-0.00147648311654386,-0.0717608051216540,-0.140999972214618,-0.141250151321324,-0.140817441856875,-0.139720335418141,-0.0710998940105156,-0.00146281625784483,0.0681953864045793,0.136877706721972,0.137953353976935,0.138377605255834,0.138132316025700,0.137228012430967,0.0683724007273634,-0.00146663086858256,-0.0712843731398980,-0.140077631977130,-0.206914947499116,-0.208245223109711,-0.208605946346742,-0.207982011357914,-0.206399460333200,-0.203922534639367,-0.138004399909244,-0.0702142082305966,-0.00144450433800254,0.0673455468643292,0.135195374555652,0.201208437186212,0.203655217834926,0.205218561868424,0.205834935814870,0.205478583142075,0.204164444096169,0.201946453839755,0.135702664582633,0.0676017610516472,-0.00145002478537798,-0.0704812309178743,-0.138521827891124,-0.204669654648845,-0.268146341440069,-0.270995464151657,-0.272682118920578,-0.273139302355671,-0.272348474551021,-0.270341603182828,-0.267197655372971,-0.263034269482495,-0.200646692786784,-0.135737216333010,-0.0690447093018680,-0.00142032962446366,0.0662234000868692,0.132972663378132,0.197972617701692,0.260478856964504,0.264607792326756,0.267725911370380,0.269716380282929,0.270500762813460,0.270047304175529,0.268374420947498,0.265548667572074,0.261677607028376,0.198911587735960,0.133617400814410,0.0665488213193189,-0.00142733971102453,-0.0693838649252857,-0.136394862556333,-0.201597294682951,-0.264243050516448,-0.323734779899353,-0.328335254714414,-0.331688455888613,-0.333671589561867,-0.334208887767609,-0.333279411843542,-0.330919272633120,-0.327217818691791,-0.322308558554620,-0.316356552423821,-0.257996256960772,-0.196689019057791,-0.133001449697618,-0.0676345632134527,-0.00139118817391013,0.0648703783341528,0.130290670947433,0.194063527191785,0.255482902321296,0.313976111679016,0.319893348359075,0.324774349920144,0.328454752155389,0.330801583787445,0.331725843748865,0.331191558994533,0.329219588467665,0.325885407420756,0.321311320738193,0.315654623306547,0.256899026863241,0.195170893043495,0.131050073993039,0.0652533755943231,-0.00139943641266294,-0.0680337338168294,-0.133776091197905,-0.197810173223750,-0.259424344089540,-0.318044983356662,-0.373252824200223,-0.379642612691039,-0.384798441074514,-0.388550379799814,-0.390766914068511,-0.391367137507114,-0.390328722993991,-0.387690184369295,-0.383546991751962,-0.378042287370756,-0.371353903618121,-0.363679846960063,-0.309544454733604,-0.252242987578489,-0.192177779503136,-0.129887346812902,-0.0660307930672848,-0.00135805537298765,0.0633316133312202,0.127237922652425,0.189607968090738,0.249778148256397,0.307204479504650,0.361478795130277,0.369120730971060,0.375781848274938,0.381264629865245,0.385391635000708,0.388020006443968,0.389054450013133,0.388456519755240,0.386248503649798,0.382511161263446,0.377375751623250,0.371011840668228,0.363612987273895,0.309093826147346,0.251368494672392,0.190849209376018,0.128087924631119,0.0637599275023847,-0.00136727689460001,-0.0664772054664555,-0.130754447754539,-0.193434564715356,-0.253846910847194,-0.311445163345978,-0.365823098920648,-0.416716046312617,-0.424783059239398,-0.431702852595265,-0.437273991376568,-0.441321156358935,-0.443709311735483,-0.444355651082682,-0.443237357441911,-0.440393798861904,-0.435922755673847,-0.429971369596796,-0.422723396646488,-0.414384799845680,-0.405169670511125,-0.355224319627883,-0.302059257837906,-0.245936555590113,-0.187242725794364,-0.126485826081266,-0.0642806505288797,-0.00132191047254018,0.0616524529226767,0.123903590220557,0.184734185817875,0.243525479006475,0.299764555759928,0.353059673111961,0.403143628024605,0.412331073155960,0.420645684541927,0.427873647828886,0.433809196757910,0.438268698678424,0.441105077833769,0.442220582464183,0.441575852700721,0.439193700990513,0.435156912030869,0.429600467664021,0.422699580996380,0.414655511064494,0.405681211000241,0.355382455904022,0.301815081261812,0.245247231215419,0.186075245998360,0.124820549160028,0.0621140730092385,-0.00133184599455012,-0.0647617891161155,-0.127421280052359,-0.188600682758154,-0.247673172562372,-0.304122345115773,-0.357557251687777,-0.407715022362838]
# NA = 0.1200
# spsize = 1.047619047619048e-06
# wlength = 6.300000000000000e-07

# numImages = 225

# images = []
# for i in range(numImages):
#     im = np.load('C:/Users/HMCBiophotonicsLab/Documents/RPi_Data_Share/2021Jun7/im_' + str(i) + '.npy',allow_pickle=True)
#     images.append(im)
# mdic = {"imseqlow": float(images), "NA": NA, "NAshift_x": NAshift_x, "NAshift_y": NAshift_y, "spsize": spsize, "wlength": wlength}
# savemat("test_dataset.mat", mdic)

# Mount Google Drive
# When you run this, it will give you a URL. Go to that URL, copy the code, and enter it into the box
#%%
def colorbar(mappable):
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    import matplotlib.pyplot as plt
    last_axes = plt.gca()
    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    cbar = fig.colorbar(mappable, cax=cax)
    plt.sca(last_axes)
    return cbar
#%%
# Load .mat file
data_mat = '/home/kevin/Harvey Mudd/biophotonics/github/BiophotonicsLab/fpmcode/k_dataset.mat'
data_mat_norm = os.path.relpath(data_mat)
data = sio.loadmat(data_mat_norm)

#%%
imseqlow = data['imseqlow'] #sequence of low resolution images (225 images, each 128x128 in size)
bg = data['background']

imseqlow = imseqlow - np.matlib.repmat(bg,1,225).reshape(800,800,225)

#normalize darkfield images
imseqlow[:, :, 47:225] = imseqlow[:, :, 47:225]/6.316
#%%
def saveseq(imseq, name):
    for i in range(imseq.shape[2]):
        print("hello")
        plt.imsave("/home/kevin/Harvey Mudd/biophotonics/github/BiophotonicsLab/fpmcode/images/"+name+str(i)+'.jpg', imseq[:,:,i])
        
def cropped(seq, width, height):
    yMid = seq.shape[0]//2
    xMid = seq.shape[1]//2
    cropped_seq = seq[yMid-height//2:yMid+height//2,xMid-width//2:xMid+width//2,:]
    return cropped_seq
def gseq(arraysize):
    #function to return the sequence of reconstruction images
    n = (arraysize-1)/2
    sequence = np.zeros([2, (arraysize**2)])
    sequence[0,0] = n; sequence[1,0] = n
    dx=1;dy=-1;stepx=1;stepy=-1
    counter=0;direction=1
    for i in range(1,int(arraysize**2)):
        counter+=1
        if(direction ==1):
            sequence[0,i] = sequence[0,i-1]+dx
            sequence[1,i] = sequence[1,i-1]
            if (counter==abs(stepx)):
                counter = 0; direction *= -1;
                dx*=-1; stepx*=-1;
                if stepx > 0:
                    stepx+=1
                else:
                    stepx-=1
        else:
            sequence[0,i] = sequence[0,i-1]
            sequence[1,i] = sequence[1,i-1]+dy
            if counter==np.abs(stepy):
                counter = 0; direction *= -1;
                dy*=-1; stepy*=-1;
                if stepy > 0:
                    stepy+=1
                else:
                    stepy-=1
    return sequence
def initialize_params(spsize, scaling_factor,wavelength, NA, imseqlow):
    n1 = imseqlow.shape[0]
    m1 = imseqlow.shape[0]
    psize = spsize/scaling_factor
    
    n = n1 * scaling_factor
    m = m1 * scaling_factor
    k0 = 2*np.pi/wavelength

    dkx = 2*np.pi/(psize * n)      #size of pixel in the spatial frequency domain
    dky = 2*np.pi/(psize * m)
    cutoffFrequency = NA*k0
    kmax= np.pi/spsize
      
    kx_lowres = np.linspace(-kmax, kmax, n1,endpoint=False)
    ky_lowres = np.linspace(-kmax, kmax, m1,endpoint=False)
    kxm, kym = np.meshgrid(kx_lowres, ky_lowres)
    CTF = ((kxm**2 + kym **2) < cutoffFrequency ** 2)
    print(CTF.shape)
    return k0,dkx,dky,CTF
    


#imseqlow = imseqlow - bg
#print(bg.shape)
#NAshift_x = data['NAshift_x'][0] #x component of NA shift of the illumination (+ means to the right in k space)
#NAshift_y = data['NAshift_y'][0] #y component of NA shift of the illumination (+ means to down in k space)
#%%
# Resolution line plots
    
imseqlow_crop = cropped(imseqlow, 128,128)
fig,ax=plt.subplots(1,1)
ax.imshow(imseqlow_crop[:,:,0]) 
   

fig, ax = plt.subplots(1)

img = ax.matshow(imseqlow[:,:,0])
colorbar(img)

#ax[0,1].plot(imseqlow[:,0,0])

#ax[0,1].set_ylim(bottom = 0)


#%%

import colour
import colour_demosaicing
from colour_demosaicing import (demosaicing_CFA_Bayer_bilinear)
from colour_demosaicing import (masks_CFA_Bayer)

def demosaic_seq(imseq):
    print(imseq.shape)
    m = imseq.shape[0]
    n = imseq.shape[0]
    numimg = imseq.shape[2]
    imseqlowDM = np.empty((m,n,numimg))
    for i in range(numimg):
        imseqlowDM[:,:,i] = demosaicing_CFA_Bayer_bilinear(imseq[:,:,i],pattern='RGGB')[:,:,0]
    return imseqlowDM
def ssr_seq(imseq):
    m = imseq.shape[0]
    n = imseq.shape[0]

    numimg = imseq.shape[2]
    imseqlowSSR = np.empty((m, n,  arraysize**2))
    ssr_mask = masks_CFA_Bayer((m, n), pattern='RGGB')[0]
    print(ssr_mask.shape)
    return imseq * np.matlib.repmat(ssr_mask,1, numimg).reshape(m,n,numimg)



#%%

#print(im_dir[:,:,i].shape)
#print(bayer_mask)

fig, ax = plt.subplots(2, 2)
#fig.set_size_inches(6,4)
i = 1
him=ax[0, 0].imshow(imseqlow[:, :, 0])
plt.colorbar(him,ax=ax[0,0])
ax[0,0].set_title('lo res image')
ax[0,1].imshow(imseqlowSSR[:, :, 0])
ax[0,1].set_title('SSR')
ax[1,0].imshow(imseqlowDM[:,:, 0])
ax[1,0].set_title('Demosaic: RGGB')
ax[1,1].imshow(imseqlow_crop[:,:,i])
ax[1,1].set_title('low res image cropped')

# for item in ([ax[0,0].title, ax[0,0].xaxis.label, ax[0,0].yaxis.label] +
#              ax[0,0].get_xticklabels() + ax[0,0].get_yticklabels()):
#     item.set_fontsize(20)
ax[0,1].imshow(imseqlowSSR[:,:,1])

plt.tight_layout()  


#%%
def showimage(im):
    plt.figure()
    plt.imshow(im)
    plt.show()
# function to reconstruct the high res image and phase
import cv2

def phaseRetrieval(iterations, scaling_factor, k0, dkx, dky, CTF, imseq, NAshift_x, NAshift_y):
    #objectRecover = np.ones([m,n])
    numimg = imseq.shape[2]
    m = imseq.shape[0] * scaling_factor
    n = imseq.shape[0] * scaling_factor #image size of the high resolution object
#[m, n] = (512, 512)
    m1 = imseq.shape[0]  #image size of low res reconstruction (low res)
    n1 = imseq.shape[0]
    objectRecover=np.zeros((m,n))
    #objectRecover = cv2.resize(imseqlow[:, :, 0], dsize=(m, n), interpolation=cv2.INTER_CUBIC)
    imageStack = np.zeros((m,n,numimg))
    objectRecoverFT = fftshift(fft2(objectRecover))
    for i in range(iterations):
        print("iteration: ", i)
        for j in range(numimg):
            
            kxc = np.round(n/2 + k0 * NAshift_x[j]/dkx)
            kyc = np.round(m/2 + k0 * NAshift_y[j]/dky)
            kyl = np.round(kyc - (m1)/2); kyh = np.round(kyc + (m1)/2)
            kxl = np.round(kxc - (n1)/2); kxh=np.round(kxc + (n1)/2)
            kxl = int(kxl)
            kyl = int(kyl)
            kxh = int(kxh)
            kyh = int(kyh)

            lowResFT = (scaling_factor)**2 * objectRecoverFT[kyl:kyh, kxl:kxh] * CTF
            im_lowRes = ifft2(ifftshift(lowResFT));
            #showimage(np.abs(im_lowRes))
            im_lowRes = (1/scaling_factor)**2 * imseq[:,:,j] * np.exp(1j * np.angle(im_lowRes))
            lowResFT = fftshift(fft2(im_lowRes)) * CTF
            objectRecoverFT[kyl:kyh,kxl:kxh] = (1-CTF) * objectRecoverFT[kyl:kyh,kxl:kxh] + lowResFT
            imageStack[:,:,j] = objectRecoverFT
            
    objectRecover = ifft2(ifftshift(objectRecoverFT))
    return (objectRecover,objectRecoverFT, imageStack)

def phaseRetrieval2(iterations, scaling_factor, k0, dkx, dky, CTF, imseq, NAshift_x, NAshift_y):
    #objectRecover = np.ones([m,n])
    numimg = imseq.shape[2]
    m = imseq.shape[0] * scaling_factor
    n = imseq.shape[0] * scaling_factor #image size of the high resolution object
#[m, n] = (512, 512)
    m1 = imseq.shape[0]  #image size of low res reconstruction (low res)
    n1 = imseq.shape[0]
    objectRecover=np.zeros((m,n))
    pupil=1
    #objectRecover = cv2.resize(imseqlow[:, :, 0], dsize=(m, n), interpolation=cv2.INTER_CUBIC)
    objectRecoverFT = fftshift(fft2(objectRecover))
    for i in range(iterations):
        print("iteration: ", i)
        for j in range(numimg):
            
            kxc = np.round(n/2 + k0 * NAshift_x[j]/dkx)
            kyc = np.round(m/2 + k0 * NAshift_y[j]/dky)
            kyl = np.round(kyc - (m1)/2); kyh = np.round(kyc + (m1)/2)
            kxl = np.round(kxc - (n1)/2); kxh=np.round(kxc + (n1)/2)
            kxl = int(kxl)
            kyl = int(kyl)
            kxh = int(kxh)
            kyh = int(kyh)

            lowResFT_1 = (scaling_factor)**2 * objectRecoverFT[kyl:kyh, kxl:kxh] * CTF * pupil
            im_lowRes = ifft2(ifftshift(lowResFT_1));
            im_lowRes = (1/scaling_factor)**2 * imSeqLowRes[:,:,limg] * np.exp(1j * np.angle(im_lowRes))
            lowResFT_2 = fftshift(fft2(im_lowRes)) * CTF * 1/pupil
            objectRecoverFT[kyl:kyh,kxl:kxh] = objectRecoverFT[kyl:kyh,kxl:kxh] + np.conj(pupil)/(np.abs(pupil)**2).max() * (lowResFT_2 - lowResFT_1)
            pupil = pupil + np.conj(objectRecoverFT[kyl:kyh,kxl:kxh])/(np.abs(objectRecoverFT[kyl:kyh,kxl:kxh])**2).max() * (lowResFT_2 - lowResFT_1)
            
    objectRecover = ifft2(ifftshift(objectRecoverFT))
    return (objectRecover,objectRecoverFT)
#%%
import math
arraysize = 15
LEDgap = 4 # 4mm between adj LED's
#LEDheight = 56 # for caltech datasets
LEDheight = 95 # dist between LED and sample
wavelength = data['wlength'][0][0]

spsize = data['spsize'][0]
scaling_factor=4      
NA = data['NA'][0][0]
k0,dkx,dky,CTF = initialize_params(spsize,4, wavelength, NA, imseqlow_crop)


xloc,yloc = (gseq(arraysize)-(arraysize//2))*LEDgap
LED_y = [7,8,8,7,6,6,6,7,8,9,9,9,9,8,7,6,5,5,5,5,5,6,7,8,9,10,10,10,10,10,10,9,8,7,6,5,4,4,4,4,4,4,4,5,6,7,8,9,10,11,11,11,11,11,11,11,11,10,9,8,7,6,5,4,3,3,3,3,3,3,3,3,3,4,5,6,7,8,9,10,11,12,12,12,12,12,12,12,12,12,12,11,10,9,8,7,6,5,4,3,2,2,2,2,2,2,2,2,2,2,2,3,4,5,6,7,8,9,10,11,12,13,13,13,13,13,13,13,13,13,13,13,13,12,11,10,9,8,7,6,5,4,3,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]
LED_x = [7,7,6,6,6,7,8,8,8,8,7,6,5,5,5,5,5,6,7,8,9,9,9,9,9,9,8,7,6,5,4,4,4,4,4,4,4,5,6,7,8,9,10,10,10,10,10,10,10,10,9,8,7,6,5,4,3,3,3,3,3,3,3,3,3,4,5,6,7,8,9,10,11,11,11,11,11,11,11,11,11,11,10,9,8,7,6,5,4,3,2,2,2,2,2,2,2,2,2,2,2,3,4,5,6,7,8,9,10,11,12,12,12,12,12,12,12,12,12,12,12,12,11,10,9,8,7,6,5,4,3,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,10,11,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,12,11,10,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14]
rx = np.array(LED_x) - arraysize//2
ry = np.array(LED_y) - arraysize//2
rx = rx * LEDgap
ry = ry * LEDgap
dist = np.sqrt((rx)**2 + (ry)**2)

p = np.arctan2((ry), (rx))
t = np.arctan2(dist, LEDheight)

kx_rel = -(np.sin(t)*np.cos(p))
ky_rel = -(np.sin(t)*np.sin(p))

X = xloc
Y = yloc
d = np.sqrt(X**2 + Y**2)

phi = np.arctan2(yloc, xloc)
theta = np.arctan2(d, LEDheight)

NAshift_x = -(np.sin(theta)*np.cos(phi))
NAshift_y = -(np.sin(theta)*np.sin(phi))


#print(r[1,:])
#%%
fig, ax = plt.subplots(2)
ax[0].plot(xloc,yloc,'go--')
ax[0].plot(ry, rx, 'bo--')
ax.axis('equal')
ax.set_xlabel('kx relative')
ax.set_ylabel('ky relative')
ax.set_title('ky vs. kx relative')
plt.show()
#%%
print(CTF.shape)
obj, objFT,imageStack = phaseRetrieval(1, 4, k0, dkx, dky, CTF, imseqlow_crop,ky_rel,kx_rel)
#%%
def normalizeImages(imseq):
    return np.log(np.abs(imseq))

#%%
#normseq = normalizeImages(imageStack)
fig, ax = plt.subplots(2, 2)
ax[0,0].imshow(np.abs(ifftshift(ifft2(imageStack[:,:,0]))))
ax[0,0].set_title("IFFT of 0th hi-res_0")
him = ax[1,0].imshow(np.abs(fftshift(fft2(imseqlow_crop[:,:,20]))), norm=colors.LogNorm())
ax[1,0].set_title("cropped low res  FT")
ax[0,1].imshow(np.abs(imageStack[:,:,224]), norm=colors.LogNorm())
ax[0,1].set_title("imagestack_0, FT")
masked = fftshift(fft2(imseqlow_crop[:,:,0])) * CTF
ax[1,1].imshow(np.abs(masked), norm=colors.LogNorm())
ax[1,1].set_title("hi-res output")
plt.tight_layout()
saveseq(normalizeImages(imageStack), 'imstaack')

#%%
#HighResSSR, HighResFTSSR = phaseRetrieval(5, mag, k0, kx, ky, dkx, dky, CTF, imseqlowSSR)
#HighResSSR = HighResSSR * 4
imseqlowDM = demosaic_seq(imseqlow)
imseqlowSSR = ssr_seq(imseqlow)
    
        

HighRes, HighResFT = phaseRetrieval(5, mag, k0, kx, ky, dkx, dky, CTF, imseqlow_crop)
#%%
#helper function to plot things
def plot3(image, title): 
  norm_img = np.abs(image) / np.abs(image).max()
  plt.rcParams["figure.figsize"] = (40,10)
  fig, ax = plt.subplots(1, 3)
  norm1 = colors.Normalize(vmin = norm_img.min(), vmax = norm_img.max())
  #print(norm_img[0:100])
  # for i in range(0, len(norm_img)): 
  #   for j in range(0, len(norm_img[0])):
  #     if norm_img[i] = 

  
  h0 = ax[0].imshow(np.abs(image), cmap = 'viridis', vmin = 0, vmax = 5 * np.mean(np.abs(image)))
  #h0 = ax[0].imshow(norm_img, cmap = 'viridis', vmin = 0, vmax = 2 * np.mean(norm_img))

  #h0 = ax[0].imshow(norm_img, cmap = 'viridis', norm = norm1)
  colorbar(h0)
 

  ax[0].set_title("High Res Intensity " + title)
  ax[0].set_xlabel("x")
  ax[0].set_ylabel("y")
  import matplotlib.patches as mpatches
  rect=mpatches.Rectangle((1600,1300),1,200, fill = False, color = "red", linewidth = 2)
  ax[0].add_patch(rect)


  phaseimg = np.angle(image) + np.abs(np.angle(image).min())
  norm_angle = phaseimg / phaseimg.max()
  #h1 = ax[1].imshow(np.angle(image),  cmap = 'viridis', vmin = -0.5, vmax = 0.5)
  norm2 = colors.Normalize(vmin = norm_angle.min(), vmax = norm_angle.max())
  h1 = ax[1].imshow(norm_angle, cmap = 'viridis', norm = norm2)
  ax[1].set_title("High Res Phase " + title)
  ax[1].set_xlabel("x")
  ax[1].set_ylabel("y")
  colorbar(h1)

  ax[2].plot(norm_img[1300:1500, 1600])
  norm_img[1300:1500, 1595:1605] = 30000
  ax[2].set_title("line profile")
  #ax[2].set_ylim(bottom = 0, top = 1)
  ax[2].set_xlabel("distance (pixels)")
  ax[2].set_ylabel("intensity")
  
  for i in range(3): 
    for item in ([ax[i].title, ax[i].xaxis.label, ax[i].yaxis.label] +
              ax[i].get_xticklabels() + ax[i].get_yticklabels()):
      item.set_fontsize(20)
#%%
print(np.angle(HighRes) + np.abs(np.angle(HighRes).min()))
#%%
#plot3(HighRes, "Original")
plot3(HighResDM, "Demosaiced")
#plot3(HighResSSR, "SSR")
#%%
#helper function to plot things
def plot4(image, title): 
  norm_img = np.abs(image) / np.abs(image).max()
  plt.rcParams["figure.figsize"] = (40,10)
  fig, ax = plt.subplots()
  norm1 = colors.Normalize(vmin = norm_img.min(), vmax = norm_img.max())
  #print(norm_img[0:100])
  # for i in range(0, len(norm_img)): 
  #   for j in range(0, len(norm_img[0])):
  #     if norm_img[i] = 

  
  h0 = ax.imshow(np.abs(image), cmap = 'viridis', vmin = 0, vmax = 5 * np.mean(np.abs(image)))
  #h0 = ax[0].imshow(norm_img, cmap = 'viridis', vmin = 0, vmax = 2 * np.mean(norm_img))

  #h0 = ax[0].imshow(norm_img, cmap = 'viridis', norm = norm1)
  colorbar(h0)
 

  ax.set_title("High Res Intensity " + title)
  ax.set_xlabel("x")
  ax.set_ylabel("y")

plot4(HighResSSR, "SSR")

#aaaaaaAAAAAAAAAAAAAAAAAA
#%%
# RMS plot calculations
def RMS(image): 
  norm_img = np.abs(image) / np.abs(image).max()
  norm_img_sq = norm_img ** 2
  mean = np.mean(norm_img_sq)
  rms = np.sqrt(mean)
  return rms
#%%id
#calculate RMS error
def rms_error(image, truth): 
  rmsimg = RMS(image)
  rmstruth = RMS(truth)
  return (np.abs(rmstruth - rmsimg) / rmstruth) * 100

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

fig, ax = plt.subplots()


def f(x, y):
    return np.sin(x) + np.cos(y)

x = np.linspace(0, 2 * np.pi, 120)
y = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)

# ims is a list of lists, each row is a list of artists to draw in the
# current frame; here we are just animating one artist, the image, in
# each frame
ims = []
for i in range(60):
    x += np.pi / 15.
    y += np.pi / 20.
    im = ax.imshow(f(x, y), animated=True)
    if i == 0:
        ax.imshow(f(x, y))  # show an initial one first
    ims.append([im])

ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,
                                repeat_delay=1000)

# To save the animation, use e.g.
#
# ani.save("movie.mp4")
#
# or
#
# writer = animation.FFMpegWriter(
#     fps=15, metadata=dict(artist='Me'), bitrate=1800)
# ani.save("movie.mp4", writer=writer)

plt.show()7

print(RMS(HighRes))
print(RMS(HighResDM))
print(RMS(HighResSSR))
print(rms_error(HighResDM, HighRes))
print(rms_error(HighResSSR, HighRes))